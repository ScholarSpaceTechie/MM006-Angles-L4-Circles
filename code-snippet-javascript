/* ‚úÖ Circle Angles ‚Äî Option B (WordPress Code Snippets JS)
   - Paste THIS whole file into your Code Snippets (JavaScript).
   - On the page, ONLY add:
     <div id="circle-angles-game-container"></div>

   ‚úÖ No CSS leakage: all CSS scoped to #circle-angles-game-container
   ‚úÖ No ID/class conflicts: uses ca-* (not sf-*)
   ‚úÖ Safe on other pages: does nothing unless the container exists
*/
(function () {
  function initCircleAnglesGame() {
    const host = document.getElementById("circle-angles-game-container");
    if (!host) return;

    // prevent double init (WP builders / cached partial reloads)
    if (host.dataset.caInit === "1") return;
    host.dataset.caInit = "1";

    // ---------- HTML ----------
    host.innerHTML = `
      <div class="ca-game">
        <div class="ca-title-row">
          <h2 class="ca-title">
            <span>üü£</span>
            <span style="color:#ffffff">Circle Angles ‚Äî Level 4</span>
            <span class="ca-tag">MM006</span>
          </h2>

          <div class="ca-scoreboard">
            <div class="ca-pill" id="ca-score">Score: 0 / 0</div>
            <div class="ca-pill" id="ca-streak">Streak: 0 üî•</div>
            <div class="ca-pill ca-timer" id="ca-timer">‚è± ‚Äì</div>
          </div>
        </div>

        <div class="ca-control-row">
          <div class="ca-control">
            <label for="ca-topic">Topic:</label>
            <select id="ca-topic">
              <option value="mixed" selected>All Types</option>
              <option value="centre_circum">Centre ‚Üî Circumference (2√ó)</option>
              <option value="semicircle_90">Right Angle in Semi-Circle</option>
              <option value="same_segment">Angles in Same Segment</option>
              <option value="opp_segment">Angles in Opposite Segment</option>
              <option value="tangent_ext">Tangent from External Point</option>
            </select>
          </div>

          <div class="ca-control">
            <label for="ca-mode">Mode:</label>
            <select id="ca-mode">
              <option value="warmup">Warm-Up (No Timer)</option>
              <option value="easy">Easy</option>
              <option value="normal" selected>Normal</option>
              <option value="hard">Hard</option>
            </select>
          </div>
        </div>

        <div class="ca-question-box">
          <div class="ca-q-left">
            <div class="ca-sub" id="ca-instructions">
              Circle Angles Level 4 ‚Äî choose the correct answer. (10 questions per quiz)
            </div>

            <div class="ca-question-row">
              <div class="ca-question" id="ca-question">‚Äî</div>
              <div class="ca-shape" id="ca-shape" aria-hidden="true"></div>
            </div>
          </div>

          <div class="ca-q-right">
            <div class="ca-meta" id="ca-meta">Ready</div>
            <div class="ca-hint" id="ca-hint" aria-live="polite"></div>
          </div>
        </div>

        <div class="ca-options" id="ca-options"></div>

        <div class="ca-bottom">
          <div class="ca-feedback" id="ca-feedback"></div>

          <div class="ca-buttons">
            <button class="ca-btn ca-primary" id="ca-next">Start Quiz ‚ñ∂</button>
            <button class="ca-btn ca-secondary" id="ca-reset">Reset üîÑ</button>
          </div>
        </div>

        <details class="ca-rule-sheet" id="ca-rules-details">
          <summary id="ca-rules-summary">üìå Circle Rules (for revision)</summary>
          <div class="ca-sheet-grid" id="ca-sheet"></div>
        </details>
      </div>
    `;

    // ---------- Scoped CSS (NO LEAKING) ----------
    // Add only once
    if (!document.querySelector('style[data-ca-style="1"]')) {
      const style = document.createElement("style");
      style.setAttribute("data-ca-style", "1");
      style.innerHTML = `
#circle-angles-game-container .ca-game{
  background:#0b1220;
  color:#e5e7eb;
  padding:24px;
  border-radius:18px;
  max-width:980px;
  margin:24px auto;
  position:relative;
  overflow:hidden;
  border:1px solid rgba(148,163,184,0.25);
  box-shadow:0 18px 45px rgba(0,0,0,.55);
}

#circle-angles-game-container .ca-title-row{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:12px;
  flex-wrap:wrap;
}
#circle-angles-game-container .ca-title{
  margin:0;
  display:flex;
  align-items:center;
  gap:10px;
  font-size:1.45rem;
}
#circle-angles-game-container .ca-tag{
  font-size:.78rem;
  padding:3px 10px;
  border-radius:999px;
  border:1px solid rgba(99,102,241,0.45);
  background:rgba(99,102,241,0.12);
  color:#c7d2fe;
}

#circle-angles-game-container .ca-scoreboard{
  display:flex;
  gap:8px;
  align-items:center;
  flex-wrap:wrap;
}
#circle-angles-game-container .ca-pill{
  font-size:.86rem;
  padding:5px 12px;
  border-radius:999px;
  border:1px solid rgba(148,163,184,0.28);
  background:rgba(15,23,42,0.65);
}
#circle-angles-game-container .ca-timer{
  border-color:rgba(34,197,94,0.35);
  background:rgba(34,197,94,0.12);
  color:#d1fae5;
}

#circle-angles-game-container .ca-control-row{
  margin-top:12px;
  display:flex;
  gap:12px;
  flex-wrap:wrap;
  align-items:center;
}
#circle-angles-game-container .ca-control{
  display:flex;
  gap:8px;
  align-items:center;
  font-size:.9rem;
}
#circle-angles-game-container .ca-control select{
  background:#050b16;
  color:#e5e7eb;
  border:1px solid rgba(148,163,184,0.35);
  border-radius:999px;
  padding:4px 12px;
  font-size:.9rem;
  outline:none;
}

#circle-angles-game-container .ca-question-box{
  margin-top:14px;
  padding:14px;
  border-radius:14px;
  border:1px solid rgba(148,163,184,0.25);
  background:rgba(2,6,23,0.65);
  display:flex;
  justify-content:space-between;
  gap:16px;
  flex-wrap:wrap;
}
#circle-angles-game-container .ca-q-left{ min-width:280px; flex:1; }
#circle-angles-game-container .ca-sub{ font-size:.92rem; opacity:.9; margin-bottom:6px; }

#circle-angles-game-container .ca-question-row{
  display:flex;
  gap:14px;
  align-items:flex-start;
  justify-content:space-between;
  flex-wrap:wrap;
}
#circle-angles-game-container .ca-question{
  font-size:1.12rem;
  font-weight:800;
  letter-spacing:.2px;
  flex:1;
  min-width:240px;
  line-height:1.25;
}
#circle-angles-game-container .ca-shape{
  width:260px;
  max-width:100%;
  display:flex;
  justify-content:flex-end;
}
#circle-angles-game-container .ca-shape svg{
  width:260px;
  height:auto;
  display:block;
  opacity:.95;
}

#circle-angles-game-container .ca-q-right{ min-width:260px; }
#circle-angles-game-container .ca-meta{ font-size:.95rem; opacity:.9; }
#circle-angles-game-container .ca-hint{
  margin-top:8px;
  font-size:.92rem;
  color:#c7d2fe;
  min-height:18px;
}

#circle-angles-game-container .ca-options{
  margin-top:14px;
  display:grid;
  grid-template-columns:repeat(2,1fr);
  gap:10px;
}
#circle-angles-game-container .ca-option{
  position:relative;
  border-radius:14px;
  border:1px solid rgba(148,163,184,0.25);
  background:rgba(15,23,42,0.55);
  padding:12px 12px 12px 46px;
  cursor:pointer;
  transition:transform .12s, border-color .12s, box-shadow .12s;
}
#circle-angles-game-container .ca-option:hover{
  transform:translateY(-2px);
  border-color:rgba(99,102,241,0.65);
  box-shadow:0 10px 24px rgba(0,0,0,.45);
}
#circle-angles-game-container .ca-option.correct{
  border-color:rgba(34,197,94,0.9) !important;
  box-shadow:0 0 0 2px rgba(34,197,94,0.25), 0 14px 28px rgba(0,0,0,.45);
}
#circle-angles-game-container .ca-option.wrong{
  border-color:rgba(239,68,68,0.9) !important;
  box-shadow:0 0 0 2px rgba(239,68,68,0.2), 0 14px 28px rgba(0,0,0,.45);
}
#circle-angles-game-container .ca-letter{
  position:absolute;
  left:12px;
  top:10px;
  width:26px;
  height:26px;
  border-radius:999px;
  display:flex;
  align-items:center;
  justify-content:center;
  font-weight:800;
  font-size:.9rem;
  border:1px solid rgba(148,163,184,0.35);
  background:rgba(2,6,23,0.65);
  color:#e5e7eb;
}
#circle-angles-game-container .ca-main{
  font-size:1.02rem;
  font-weight:780;
  letter-spacing:.2px;
}
#circle-angles-game-container .ca-subtext{
  margin-top:6px;
  font-size:.88rem;
  opacity:.85;
  line-height:1.25;
}

#circle-angles-game-container .ca-bottom{
  margin-top:12px;
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:10px;
  flex-wrap:wrap;
}
#circle-angles-game-container .ca-feedback{ min-height:22px; font-size:1rem; }
#circle-angles-game-container .ca-buttons{ display:flex; gap:10px; flex-wrap:wrap; }
#circle-angles-game-container .ca-btn{
  border:none;
  border-radius:999px;
  padding:8px 16px;
  cursor:pointer;
  font-weight:700;
}
#circle-angles-game-container .ca-primary{
  background:linear-gradient(135deg,#6366f1,#22c55e);
  color:#06101f;
}
#circle-angles-game-container .ca-primary:hover{
  transform:translateY(-1px);
  box-shadow:0 10px 24px rgba(99,102,241,.35);
}
#circle-angles-game-container .ca-secondary{
  background:rgba(2,6,23,0.65);
  border:1px solid rgba(148,163,184,0.35);
  color:#e5e7eb;
}
#circle-angles-game-container .ca-secondary:hover{
  background:rgba(15,23,42,0.7);
}

#circle-angles-game-container .ca-rule-sheet{
  margin-top:14px;
  border-radius:14px;
  border:1px solid rgba(148,163,184,0.25);
  background:rgba(2,6,23,0.45);
  padding:10px 12px;
}
#circle-angles-game-container .ca-rule-sheet summary{
  cursor:pointer;
  font-weight:700;
  color:#e5e7eb;
}
#circle-angles-game-container .ca-sheet-grid{
  margin-top:10px;
  display:grid;
  grid-template-columns:repeat(2,1fr);
  gap:10px;
}
#circle-angles-game-container .ca-sheet-card{
  border:1px solid rgba(148,163,184,0.22);
  background:rgba(15,23,42,0.55);
  border-radius:12px;
  padding:10px 12px;
}
#circle-angles-game-container .ca-sheet-title{
  font-weight:800;
  margin-bottom:6px;
}
#circle-angles-game-container .ca-sheet-line{
  font-size:.9rem;
  opacity:.92;
  line-height:1.28;
}

.ca-confetti{
  position:fixed;
  z-index:99999;
  pointer-events:none;
  animation:ca-confetti-fall 1.8s ease-out forwards;
  font-size:1.7rem;
}
@keyframes ca-confetti-fall{
  0%{transform:translateY(-10vh) rotate(0deg);opacity:0;}
  10%{opacity:1;}
  100%{transform:translateY(110vh) rotate(340deg);opacity:0;}
}
.ca-stream{
  position:fixed;
  z-index:99999;
  pointer-events:none;
  font-size:1.7rem;
  user-select:none;
  will-change:transform, opacity;
}

@media(max-width:820px){
  #circle-angles-game-container .ca-options{grid-template-columns:1fr;}
  #circle-angles-game-container .ca-sheet-grid{grid-template-columns:1fr;}
  #circle-angles-game-container .ca-shape svg{ width:240px; }
}
      `;
      document.head.appendChild(style);
    }

    // ---------- Helpers ----------
    function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
    function pick(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
    function shuffle(arr) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    const emojis = ["üéâ","üéä","üéà","‚ú®","üí´","üåü","ü§©","üíØ","ü•á","ü•à","ü•â"];

    // ---------- Audio (runs globally but only unlocks if host is interacted with) ----------
    const SFX = {
      correct: "https://scholarspace.academy/wp-content/uploads/2026/01/Games-Correct1.mp3",
      wrong:   "https://scholarspace.academy/wp-content/uploads/2026/01/Games-Wrong1.mp3",
      timeup:  "https://scholarspace.academy/wp-content/uploads/2026/01/Games-Timeup1.mp3"
    };
    const sfxCorrect = new Audio(SFX.correct);
    const sfxWrong   = new Audio(SFX.wrong);
    const sfxTimeUp  = new Audio(SFX.timeup);
    [sfxCorrect, sfxWrong, sfxTimeUp].forEach(a => { a.preload = "auto"; a.volume = 0.55; });

    let audioUnlocked = false;
    function unlockAudioOnce() {
      if (audioUnlocked) return;
      audioUnlocked = true;
      [sfxCorrect, sfxWrong, sfxTimeUp].forEach(a => {
        try {
          a.muted = true;
          const p = a.play();
          if (p && typeof p.then === "function") {
            p.then(() => { a.pause(); a.currentTime = 0; a.muted = false; }).catch(() => { a.muted = false; });
          } else {
            a.muted = false;
          }
        } catch (e) {}
      });
    }
    host.addEventListener("pointerdown", unlockAudioOnce, { once: true });
    host.addEventListener("touchstart", unlockAudioOnce, { once: true });

    function safePlay(a) { try { a.currentTime = 0; const p = a.play(); if (p && p.catch) p.catch(() => {}); } catch (e) {} }
    const playCorrectSound = () => safePlay(sfxCorrect);
    const playWrongSound   = () => safePlay(sfxWrong);
    const playTimeUpSound  = () => safePlay(sfxTimeUp);

    // ---------- Confetti ----------
    function shootPopperStream(originX, originY, side, totalCount) {
      let count = 0;
      const interval = setInterval(() => {
        if (count >= totalCount) { clearInterval(interval); return; }

        const span = document.createElement("span");
        span.className = "ca-stream";
        span.textContent = emojis[Math.floor(Math.random() * emojis.length)];
        document.body.appendChild(span);

        const startX = originX + (Math.random() - 0.5) * 16;
        const startY = originY + (Math.random() - 0.5) * 16;

        const screenW = window.innerWidth || 1200;
        const screenH = window.innerHeight || 800;

        const targetX = screenW * 0.5 + (Math.random() - 0.5) * screenW * 0.25;
        const targetY = screenH * 0.32 + (Math.random() - 0.5) * screenH * 0.12;

        const controlX =
          side === "left"
            ? screenW * 0.28 + Math.random() * screenW * 0.12
            : screenW * 0.72 - Math.random() * screenW * 0.12;
        const controlY = screenH * 0.12 + Math.random() * screenH * 0.1;

        const startTime = performance.now();
        const duration = 900 + Math.random() * 350;

        function animate(now) {
          const elapsed = now - startTime;
          const tRaw = elapsed / duration;
          if (tRaw >= 1) { span.remove(); return; }

          const t = 1 - Math.pow(1 - tRaw, 2);
          const u = 1 - t;

          const x = u*u*startX + 2*u*t*controlX + t*t*targetX;
          const y = u*u*startY + 2*u*t*controlY + t*t*targetY;

          span.style.left = x + "px";
          span.style.top  = y + "px";

          const opacity = t < 0.55 ? 1 : 1 - (t - 0.55) / 0.45;
          span.style.opacity = String(Math.max(0, Math.min(1, opacity)));
          requestAnimationFrame(animate);
        }
        requestAnimationFrame(animate);
        count++;
      }, 24);
    }

    function launchConfetti(intensity) {
      const base = 30;
      const factor = intensity || 1;
      const count = Math.max(12, Math.round(base * factor));

      for (let i = 0; i < count; i++) {
        const span = document.createElement("span");
        span.className = "ca-confetti";
        span.textContent = emojis[Math.floor(Math.random() * emojis.length)];
        span.style.left = Math.random() * 100 + "vw";
        span.style.top = Math.random() * 5 - 10 + "vh";
        span.style.animationDelay = Math.random() * 0.7 + "s";
        span.style.animationDuration = 1.4 + Math.random() * 0.8 + "s";
        document.body.appendChild(span);
        setTimeout(() => span.remove(), 2200);
      }

      const h = window.innerHeight || 800;
      const w = window.innerWidth || 1200;
      const totalPerSide = 20 + Math.round(6 * factor);
      shootPopperStream(80, h - 80, "left", totalPerSide);
      shootPopperStream(w - 80, h - 80, "right", totalPerSide);
    }

    // ===========================================
    // Circle diagram engine (template SVG)
    // ===========================================
    const W = 520, H = 360;
    const cx = 260, cy = 180;
    const R = 130;

    function degToRad(d) { return (d * Math.PI) / 180; }
    function polar(angleDeg, radius = R) {
      const t = degToRad(angleDeg);
      return { x: cx + radius * Math.cos(t), y: cy + radius * Math.sin(t) };
    }
    function fmtAngle(n) { return `${n}¬∞`; }
    function fmtLen(n) { return `${n} cm`; }
    function near(n, step = 5) {
      return shuffle([n - step, n + step, n - 2 * step, n + 2 * step].filter(x => x > 0));
    }

    function svgStart() { return `<svg viewBox="0 0 ${W} ${H}" xmlns="http://www.w3.org/2000/svg">`; }
    function svgEnd() { return `</svg>`; }
    function drawCircle() {
      return `<circle cx="${cx}" cy="${cy}" r="${R}" fill="none" stroke="rgba(255,255,255,.88)" stroke-width="3" opacity="0.92"/>`;
    }
    function drawLine(a, b, dashed = false) {
      return `<line x1="${a.x}" y1="${a.y}" x2="${b.x}" y2="${b.y}" stroke="rgba(255,255,255,.88)" stroke-width="3" ${dashed ? 'stroke-dasharray="7 7"' : ""}/>`;
    }
    function drawPoint(p, label, dx = 10, dy = -10) {
      return `
        <circle cx="${p.x}" cy="${p.y}" r="4.5" fill="rgba(255,255,255,.92)"/>
        <text x="${p.x + dx}" y="${p.y + dy}" font-size="18" fill="rgba(255,255,255,.92)" font-weight="800">${label}</text>
      `;
    }
    function drawLabel(text, x, y) {
      return `<text x="${x}" y="${y}" font-size="16" fill="rgba(255,255,255,.85)" font-weight="700">${text}</text>`;
    }
    function drawTangentAtPoint(A, angleDeg, length = 220) {
      const dir = angleDeg + 90;
      const p1 = polar(dir, length / 2);
      const p2 = polar(dir + 180, length / 2);
      const v1 = { x: A.x + (p1.x - cx), y: A.y + (p1.y - cy) };
      const v2 = { x: A.x + (p2.x - cx), y: A.y + (p2.y - cy) };
      return `<line x1="${v1.x}" y1="${v1.y}" x2="${v2.x}" y2="${v2.y}" stroke="rgba(255,255,255,.88)" stroke-width="3"/>`;
    }

    function tplCentreCircumference() {
      const centreAngle = pick([60, 70, 80, 90, 100, 110, 120, 130, 140]);
      const circumAngle = Math.round(centreAngle / 2);

      const aDeg = randInt(20, 70);
      const bDeg = aDeg + centreAngle;
      const A = polar(aDeg);
      const B = polar(bDeg);
      const O = { x: cx, y: cy };

      const useRight = Math.random() < 0.5;
      const cDeg = useRight ? randInt(bDeg + 25, bDeg + 120) : randInt(aDeg - 120, aDeg - 25);
      const C = polar(cDeg);

      const askCentre = Math.random() < 0.5;
      const given = askCentre ? circumAngle : centreAngle;
      const answer = askCentre ? centreAngle : circumAngle;

      const question = askCentre
        ? `Given ‚à†ACB = ${fmtAngle(given)}. Find ‚à†AOB.`
        : `Given ‚à†AOB = ${fmtAngle(given)}. Find ‚à†ACB.`;

      const options = shuffle([fmtAngle(answer), ...near(answer, 5).slice(0, 3).map(fmtAngle)]);

      const svg = [
        svgStart(),
        drawCircle(),
        drawLine(O, A),
        drawLine(O, B),
        drawLine(A, B),
        drawLine(C, A),
        drawLine(C, B),
        drawPoint(O, "O", 10, 16),
        drawPoint(A, "A"),
        drawPoint(B, "B"),
        drawPoint(C, "C"),
        drawLabel("Same arc AB ‚Üí centre angle is double", 14, 26),
        svgEnd(),
      ].join("");

      return { topicKey: "centre_circum", rule: "Angle at Centre = 2 √ó Angle at Circumference", question, answerText: fmtAngle(answer), options, svg };
    }

    function tplSemicircleRightAngle() {
      const aDeg = randInt(0, 179);
      const bDeg = aDeg + 180;
      const A = polar(aDeg);
      const B = polar(bDeg);
      const C = polar(randInt(aDeg + 35, aDeg + 145));
      const O = { x: cx, y: cy };

      const answer = 90;
      const options = shuffle([fmtAngle(90), fmtAngle(80), fmtAngle(100), fmtAngle(70)]);

      const svg = [
        svgStart(),
        drawCircle(),
        drawLine(A, B),
        drawLine(A, C),
        drawLine(B, C),
        drawPoint(O, "O", 10, 16),
        drawPoint(A, "A"),
        drawPoint(B, "B"),
        drawPoint(C, "C"),
        drawLabel("AB is diameter ‚Üí ‚à†ACB = 90¬∞", 14, 26),
        svgEnd(),
      ].join("");

      return { topicKey: "semicircle_90", rule: "Right Angle in a Semi-Circle", question: "AB is a diameter. Find ‚à†ACB.", answerText: fmtAngle(answer), options, svg };
    }

    function tplSameSegment() {
      const aDeg = randInt(10, 80);
      const bDeg = randInt(200, 270);
      const A = polar(aDeg);
      const B = polar(bDeg);

      const pDeg = randInt(100, 150);
      const qDeg = randInt(155, 195);
      const P = polar(pDeg);
      const Q = polar(qDeg);

      const given = pick([25, 30, 35, 40, 45, 50, 55, 60]);
      const answer = given;

      const question = Math.random() < 0.5
        ? `Given ‚à†APB = ${fmtAngle(given)}. Find ‚à†AQB.`
        : `Given ‚à†AQB = ${fmtAngle(given)}. Find ‚à†APB.`;

      const options = shuffle([fmtAngle(answer), ...near(answer, 5).slice(0, 3).map(fmtAngle)]);

      const svg = [
        svgStart(),
        drawCircle(),
        drawLine(A, B),
        drawLine(P, A),
        drawLine(P, B),
        drawLine(Q, A),
        drawLine(Q, B),
        drawPoint(A, "A"),
        drawPoint(B, "B"),
        drawPoint(P, "P"),
        drawPoint(Q, "Q"),
        drawLabel("Same chord AB ‚Üí angles in same segment are equal", 14, 26),
        svgEnd(),
      ].join("");

      return { topicKey: "same_segment", rule: "Angles in Same Segment", question, answerText: fmtAngle(answer), options, svg };
    }

    function tplOppositeSegment() {
      const aDeg = randInt(20, 140);
      const A = polar(aDeg);

      const bDeg = aDeg + randInt(40, 110);
      const B = polar(bDeg);

      const cDeg = aDeg - randInt(70, 140);
      const C = polar(cDeg);

      const given = pick([20, 25, 30, 35, 40, 45, 50, 55, 60]);
      const answer = given;

      const options = shuffle([fmtAngle(answer), ...near(answer, 5).slice(0, 3).map(fmtAngle)]);

      const svg = [
        svgStart(),
        drawCircle(),
        drawTangentAtPoint(A, aDeg),
        drawLine(A, B),
        drawLine(C, A),
        drawLine(C, B),
        drawPoint(A, "A"),
        drawPoint(B, "B"),
        drawPoint(C, "C"),
        drawLabel("Tangent‚Äìchord angle = opposite arc angle", 14, 26),
        svgEnd(),
      ].join("");

      return { topicKey: "opp_segment", rule: "Angles in Opposite Segment", question: `Angle between tangent at A and chord AB is ${fmtAngle(given)}. Find ‚à†ACB.`, answerText: fmtAngle(answer), options, svg };
    }

    function tplTangentsExternalPoint() {
      const pDeg = randInt(210, 330);
      const P = polar(pDeg, R + 120);

      const spread = randInt(25, 40);
      const A = polar(pDeg - spread);
      const B = polar(pDeg + spread);

      const len = pick([6, 7, 8, 9, 10, 12, 14, 15]);
      const answer = len;

      const options = shuffle([fmtLen(answer), fmtLen(answer + 2), fmtLen(Math.max(1, answer - 1)), fmtLen(answer + 1)]);

      const svg = [
        svgStart(),
        drawCircle(),
        drawLine(P, A),
        drawLine(P, B),
        drawLine({ x: cx, y: cy }, A, true),
        drawLine({ x: cx, y: cy }, B, true),
        drawPoint({ x: cx, y: cy }, "O", 10, 16),
        drawPoint(P, "P"),
        drawPoint(A, "A"),
        drawPoint(B, "B"),
        drawLabel("PA = PB (tangents from same external point)", 14, 26),
        svgEnd(),
      ].join("");

      return { topicKey: "tangent_ext", rule: "Tangent from External Point", question: `From point P, PA and PB are tangents. If PA = ${fmtLen(len)}, find PB.`, answerText: fmtLen(answer), options, svg };
    }

    const GEN = {
      mixed:        [tplCentreCircumference, tplSemicircleRightAngle, tplSameSegment, tplOppositeSegment, tplTangentsExternalPoint],
      centre_circum:[tplCentreCircumference],
      semicircle_90:[tplSemicircleRightAngle],
      same_segment: [tplSameSegment],
      opp_segment:  [tplOppositeSegment],
      tangent_ext:  [tplTangentsExternalPoint],
    };

    function makeQuestion(topicKey) {
      const pool = GEN[topicKey] || GEN.mixed;
      return pick(pool)();
    }

    // ---------- Rule sheet ----------
    const RULE_SHEET = [
      { title: "Centre ‚Üî Circumference (2√ó)", lines: ["Angle at centre = 2 √ó angle at circumference (same arc)."] },
      { title: "Right angle in semi-circle", lines: ["Angle subtended by a diameter is 90¬∞."] },
      { title: "Same segment", lines: ["Angles in the same segment are equal (same chord + same arc)."] },
      { title: "Opposite segment", lines: ["Angle between tangent and chord = angle in opposite arc."] },
      { title: "Tangents from external point", lines: ["Tangents from the same external point are equal (PA = PB)."] },
    ];

    // ---------- Elements (scoped) ----------
    const q = (sel) => host.querySelector(sel);

    const topicSel = q("#ca-topic");
    const modeSel  = q("#ca-mode");

    const scoreEl  = q("#ca-score");
    const streakEl = q("#ca-streak");
    const timerEl  = q("#ca-timer");

    const questionEl = q("#ca-question");
    const shapeEl    = q("#ca-shape");
    const metaEl     = q("#ca-meta");
    const hintEl     = q("#ca-hint");
    const feedbackEl = q("#ca-feedback");
    const optionsEl  = q("#ca-options");

    const nextBtn  = q("#ca-next");
    const resetBtn = q("#ca-reset");

    const rulesDetails = q("#ca-rules-details");
    const rulesSummary = q("#ca-rules-summary");
    const sheetEl      = q("#ca-sheet");

    // ---------- State ----------
    const TOTAL_QUESTIONS = 10;
    const OPTIONS_COUNT = 4;

    const DIFF = {
      warmup: { time: 0 },
      easy:   { time: 60 },
      normal: { time: 45 },
      hard:   { time: 30 },
    };

    let inProgress = false;
    let locked = false;
    let attemptedThisQ = false;

    let score = 0;
    let total = 0;
    let streak = 0;
    let qIndex = 0;

    let timerId = null;
    let timeLeft = 0;

    let current = null;

    const letters = ["A","B","C","D"];

    function isWarmup() { return modeSel.value === "warmup"; }
    function getModeCfg(){ return DIFF[modeSel.value] || DIFF.normal; }

    function updateScore(){
      scoreEl.textContent = `Score: ${score} / ${total}`;
      streakEl.textContent = `Streak: ${streak} üî•`;
    }

    function stopTimer(){
      if (timerId) clearInterval(timerId);
      timerId = null;
    }

    function startTimer(){
      stopTimer();
      const cfg = getModeCfg();
      timeLeft = cfg.time;

      if (isWarmup() || cfg.time <= 0) {
        timerEl.textContent = "‚òï Warm-Up (No Timer)";
        return;
      }

      timerEl.textContent = `‚è± ${timeLeft}s`;
      timerId = setInterval(() => {
        timeLeft--;
        if (timeLeft <= 0) {
          timeLeft = 0;
          timerEl.textContent = "‚è± 0s";
          stopTimer();
          timeUp();
        } else {
          timerEl.textContent = `‚è± ${timeLeft}s`;
        }
      }, 1000);
    }

    function timeUp(){
      if (locked || isWarmup() || !inProgress) return;
      locked = false;
      feedbackEl.textContent = "‚è∞ Time‚Äôs up! You can still answer for 0.5 points.";
      playTimeUpSound();
    }

    function closeRules(){
      if (rulesDetails) rulesDetails.open = false;
    }

    function renderRuleSheet(){
      if (!sheetEl) return;
      sheetEl.innerHTML = "";
      RULE_SHEET.forEach(sec => {
        const card = document.createElement("div");
        card.className = "ca-sheet-card";
        card.innerHTML = `<div class="ca-sheet-title">${sec.title}</div>`;
        sec.lines.forEach(t => {
          const line = document.createElement("div");
          line.className = "ca-sheet-line";
          line.textContent = `‚Ä¢ ${t}`;
          card.appendChild(line);
        });
        sheetEl.appendChild(card);
      });
    }

    function applyRulesPenalty(){
      if (!inProgress || isWarmup()) return;
      score -= 0.5;
      updateScore();
    }

    // ---------- Game flow ----------
    function startQuiz(){
      score = 0;
      total = 0;
      streak = 0;
      qIndex = 0;

      inProgress = true;
      locked = false;
      attemptedThisQ = false;

      feedbackEl.textContent = "";
      hintEl.textContent = "";
      updateScore();

      topicSel.disabled = true;
      modeSel.disabled = true;

      nextBtn.textContent = "Next Question ‚ñ∂";
      nextBtn.disabled = true;

      closeRules();
      nextQuestion();
    }

    function endQuiz(){
      stopTimer();
      inProgress = false;
      locked = true;
      attemptedThisQ = false;

      topicSel.disabled = false;
      modeSel.disabled = false;

      metaEl.textContent = `Quiz finished (${TOTAL_QUESTIONS} questions)`;
      questionEl.textContent = "‚Äî";
      shapeEl.innerHTML = "";
      hintEl.textContent = "";
      optionsEl.innerHTML = "";
      timerEl.textContent = isWarmup() ? "‚òï Warm-Up (No Timer)" : "‚è± ‚Äì";

      feedbackEl.textContent = isWarmup()
        ? "‚úÖ Warm-Up complete! (No score recorded.)"
        : `‚úÖ Quiz complete! Final score: ${score} / ${total}`;

      nextBtn.textContent = "Restart Quiz ‚Üª";
      nextBtn.disabled = false;

      closeRules();
    }

    function resetQuiz(){
      stopTimer();
      inProgress = false;
      locked = false;
      attemptedThisQ = false;

      score = 0; total = 0; streak = 0; qIndex = 0;

      topicSel.disabled = false;
      modeSel.disabled = false;

      updateScore();
      metaEl.textContent = "Ready";
      questionEl.textContent = "‚Äî";
      shapeEl.innerHTML = "";
      hintEl.textContent = "";
      optionsEl.innerHTML = "";
      timerEl.textContent = isWarmup() ? "‚òï Warm-Up (No Timer)" : "‚è± ‚Äì";
      feedbackEl.textContent = "Choose your topic + mode, then press Start Quiz.";
      nextBtn.textContent = "Start Quiz ‚ñ∂";
      nextBtn.disabled = false;

      closeRules();
    }

    function nextQuestion(){
      if (!inProgress) return;
      if (qIndex >= TOTAL_QUESTIONS) { endQuiz(); return; }

      closeRules();
      stopTimer();
      locked = false;
      attemptedThisQ = false;
      nextBtn.disabled = true;

      feedbackEl.textContent = "";
      optionsEl.innerHTML = "";
      hintEl.textContent = "";

      qIndex++;
      metaEl.textContent = `Question ${qIndex} of ${TOTAL_QUESTIONS}`;

      current = makeQuestion(topicSel.value);

      questionEl.textContent = current.question;
      shapeEl.innerHTML = current.svg;

      const opts = current.options.slice(0, OPTIONS_COUNT);
      opts.forEach((txt, i) => {
        const card = document.createElement("div");
        card.className = "ca-option";
        card.dataset.correct = (txt === current.answerText) ? "1" : "0";
        card.innerHTML = `
          <div class="ca-letter">${letters[i] || "?"}</div>
          <div class="ca-main">${txt}</div>
          <div class="ca-subtext">${current.rule}</div>
        `;
        card.addEventListener("click", () => handlePick(card));
        optionsEl.appendChild(card);
      });

      startTimer();
    }

    function revealCorrectOption(){
      optionsEl.querySelectorAll(".ca-option").forEach(c => {
        if (c.dataset.correct === "1") c.classList.add("correct");
      });
    }

    function handlePick(card){
      if (locked || !inProgress) return;

      const isCorrect = card.dataset.correct === "1";
      attemptedThisQ = true;
      nextBtn.disabled = false;

      if (isWarmup()){
        locked = true;
        if (isCorrect){
          feedbackEl.textContent = "‚úÖ Correct!";
          card.classList.add("correct");
          revealCorrectOption();
          launchConfetti(2);
          playCorrectSound();
        } else {
          feedbackEl.textContent = `‚ùå Not quite. Correct answer: ${current.answerText}`;
          card.classList.add("wrong");
          revealCorrectOption();
          playWrongSound();
        }
        return;
      }

      const withinTime = timeLeft > 0;

      locked = true;
      stopTimer();
      total++;

      if (withinTime){
        if (isCorrect){
          score += 1;
          streak++;
          feedbackEl.textContent = "‚úÖ Correct!";
          card.classList.add("correct");
          revealCorrectOption();
          launchConfetti(3);
          playCorrectSound();
        } else {
          streak = 0;
          feedbackEl.textContent = `‚ùå Wrong. Correct: ${current.answerText}`;
          card.classList.add("wrong");
          revealCorrectOption();
          playWrongSound();
        }
      } else {
        if (isCorrect){
          score += 0.5;
          streak = 0;
          feedbackEl.textContent = "üü° Correct (after time) ‚Üí +0.5 pts.";
          card.classList.add("correct");
          revealCorrectOption();
          launchConfetti(1);
          playCorrectSound();
        } else {
          streak = 0;
          feedbackEl.textContent = `‚ùå Wrong (0 pts). Correct: ${current.answerText}`;
          card.classList.add("wrong");
          revealCorrectOption();
          playWrongSound();
        }
      }

      updateScore();
    }

    // Rules sheet penalty confirm
    if (rulesSummary) {
      rulesSummary.addEventListener("click", (e) => {
        const willOpen = !rulesDetails.open;
        if (!willOpen) return;
        if (isWarmup()) return;

        const ok = window.confirm("‚ö†Ô∏è Opening Circle Rules will -0.5 marks.\n\nDo you want to open it?");
        if (!ok) { e.preventDefault(); return; }

        if (inProgress){
          applyRulesPenalty();
          feedbackEl.textContent = "‚ö†Ô∏è -0.5 marks (Circle Rules opened).";
        }
      });
    }

    // Buttons
    nextBtn.addEventListener("click", () => {
      if (!inProgress) { startQuiz(); return; }
      if (!attemptedThisQ) {
        feedbackEl.textContent = "‚ö†Ô∏è No skipping: please attempt this question first.";
        return;
      }
      nextQuestion();
    });

    resetBtn.addEventListener("click", resetQuiz);

    modeSel.addEventListener("change", () => {
      if (!inProgress) timerEl.textContent = isWarmup() ? "‚òï Warm-Up (No Timer)" : "‚è± ‚Äì";
    });

    // Init
    renderRuleSheet();
    resetQuiz();
  }

  // WP builders sometimes load content after DOMContentLoaded
  // Run immediately + again after short delay (safe due to caInit guard)
  function boot() {
    initCircleAnglesGame();
    setTimeout(initCircleAnglesGame, 300);
    setTimeout(initCircleAnglesGame, 1200);
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", boot);
  } else {
    boot();
  }
})();
